    %   Copyright (C) 2013 Heidelberg University 
    %   
    %   Developed at CKM (Computerunterstützte Klinische Medizin),
    %   Medical Faculty Mannheim, Heidelberg University, Mannheim, 
    %   Germany
    %   
    %   
    %   LICENCE
    %   
    %   CKM PhM Software Library, Release 1.0 (c) 2013, Heidelberg 
    %   University (the "Software")
    %   
    %   The Software remains the property of Heidelberg University ("the
    %   University").
    %   
    %   The Software is distributed "AS IS" under this Licence solely for
    %   non-commercial use in the hope that it will be useful, but in order
    %   that the University as a charitable foundation protects its assets for
    %   the benefit of its educational and research purposes, the University
    %   makes clear that no condition is made or to be implied, nor is any
    %   warranty given or to be implied, as to the accuracy of the Software,
    %   or that it will be suitable for any particular purpose or for use
    %   under any specific conditions. Furthermore, the University disclaims
    %   all responsibility for the use which is made of the Software. It
    %   further disclaims any liability for the outcomes arising from using
    %   the Software.
    %   
    %   The Licensee agrees to indemnify the University and hold the
    %   University harmless from and against any and all claims, damages and
    %   liabilities asserted by third parties (including claims for
    %   negligence) which arise directly or indirectly from the use of the
    %   Software or the sale of any products based on the Software.
    %   
    %   No part of the Software may be reproduced, modified, transmitted or
    %   transferred in any form or by any means, electronic or mechanical,
    %   without the express permission of the University. The permission of
    %   the University is not required if the said reproduction, modification,
    %   transmission or transference is done without financial return, the
    %   conditions of this Licence are imposed upon the receiver of the
    %   product, and all original and amended source code is included in any
    %   transmitted product. You may be held legally responsible for any
    %   copyright infringement that is caused or encouraged by your failure to
    %   abide by these terms and conditions.
    %   
    %   You are not permitted under this Licence to use this Software
    %   commercially. Use for which any financial return is received shall be
    %   defined as commercial use, and includes (1) integration of all or part
    %   of the source code or the Software into a product for sale or license
    %   by or on behalf of Licensee to third parties or (2) use of the
    %   Software or any derivative of it for research with the final aim of
    %   developing software products for sale or license to a third party or
    %   (3) use of the Software or any derivative of it for research with the
    %   final aim of developing non-software products for sale or license to a
    %   third party, or (4) use of the Software to provide any service to an
    %   external organisation for which payment is received. If you are
    %   interested in using the Software commercially, please contact 
    %   Prof. Dr. Lothar Schad (lothar.schad@medma.uni-heidelberg.de).
    %
    %Method Description:
    %-------------------
    %simple script to iterate over all results/datsets and plot the
    %corresponding quality parameters, sorted by the corresponding site

Marker          = 'o';
MarkerSize      = 2;
Color           = 'red';
PlotSTD         = 1;
SavePlot        = 1;
PlotMeanLines   = 1;
ResolutionThreshold = 200;


SiteLimit = '';
ManuLimit = '';
PlotList     = { ...
{ 0, 1, 'Result_AP', 'PhantomDiameter' }; ...
{ 0, 2, 'Result_AP', 'PhantomDiameterVector' }; ...
{ 0, 3, 'Result_AP', 'PixelBandwidth' }; ...
{ 0, 4, 'Result_AP', 'PixelBandwidthCell' }; ...
{ 0, 5, 'Result_AP', 'PixelSpacingX' }; ...
{ 0, 6, 'Result_AP', 'PixelSpacingY' }; ...
{ 0, 7, 'Result_AP', 'PixelSpacingXCell' }; ...
{ 0, 8, 'Result_AP', 'PixelSpacingYCell' }; ...
{ 0, 9, 'Result_AP', 'FOVX' }; ...
{ 0, 10, 'Result_AP', 'FOVXCell' }; ...
{ 0, 11, 'Result_AP', 'FOVY' }; ...
{ 0, 12, 'Result_AP', 'FOVYCell' }; ...
{ 0, 13, 'Result_AP', 'Width' }; ...
{ 0, 14, 'Result_AP', 'Height' }; ...
{ 0, 15, 'Result_AP', 'WidthCell' }; ...
{ 0, 16, 'Result_AP', 'HeightCell' }; ...
{ 0, 17, 'Result_AP', 'BitDepth' }; ...
{ 0, 18, 'Result_AP', 'BitDepthCell' }; ...
{ 0, 19, 'Result_AP', 'Weighting' }; ...
{ 0, 20, 'Result_AP', 'WeightingCell' }; ...
{ 0, 21, 'Result_AP', 'Sequence' }; ...
{ 0, 22, 'Result_AP', 'SequenceCell' }; ...
{ 0, 23, 'Result_AP', 'FrequencyRows' }; ...
{ 0, 24, 'Result_AP', 'FrequencyColumns' }; ...
{ 0, 25, 'Result_AP', 'PhaseRows' }; ...
{ 0, 26, 'Result_AP', 'PhaseColumns' }; ...
{ 0, 27, 'Result_AP', 'FrequencyRowsCell' }; ...
{ 0, 28, 'Result_AP', 'FrequencyColumnsCell' }; ...
{ 0, 29, 'Result_AP', 'PhaseRowsCell' }; ...
{ 0, 30, 'Result_AP', 'PhaseColumnsCell' }; ...
{ 0, 31, 'Result_AP', 'NumberOfSlices' }; ...
{ 0, 32, 'Result_AP', 'SliceThickness' }; ...
{ 0, 33, 'Result_AP', 'SliceThicknessCell' }; ...
{ 0, 34, 'Result_AP', 'SpacingBetweenSlices' }; ...
{ 0, 35, 'Result_AP', 'SpacingBetweenSlicesCell' }; ...
{ 0, 36, 'Result_AP', 'TE' }; ...
{ 0, 37, 'Result_AP', 'TECell' }; ...
{ 0, 38, 'Result_AP', 'TR' }; ...
{ 0, 39, 'Result_AP', 'TRCell' }; ...
{ 0, 40, 'Result_AP', 'MagneticFieldStrength' }; ...
{ 0, 41, 'Result_AP', 'MagneticFieldStrengthCell' }; ...
{ 0, 42, 'Result_IU', 'CenterX' }; ...
{ 0, 43, 'Result_IU', 'CenterY' }; ...
{ 0, 44, 'Result_IU', 'Radius' }; ...
{ 0, 45, 'Result_IU', 'Span' }; ...
{ 0, 46, 'Result_IU', 'Midrange' }; ...
{ 1, 47, 'Result_IU', 'IntegralUniformity' }; ...
{ 0, 48, 'Result_SNR', 'CenterX' }; ...
{ 0, 49, 'Result_SNR', 'CenterY' }; ...
{ 0, 50, 'Result_SNR', 'Radius' }; ...
{ 1, 51, 'Result_SNR', 'InnerMean' }; ...
{ 0, 52, 'Result_SNR', 'BorderMean' }; ...
{ 0, 53, 'Result_SNR', 'BorderSTD' }; ...
{ 1, 54, 'Result_SNR', 'SNR' }; ...
{ 1, 55, 'Result_SNR', 'RayFactor' }; ...
{ 0, 56, 'Result_SNR', 'GhostingRatio' }; ...
{ 0, 57, 'Result_RES', 'MTFValuesV1' }; ...
{ 0, 58, 'Result_RES', 'MTFValuesH1' }; ...
{ 0, 59, 'Result_RES', 'MTFValuesV2' }; ...
{ 0, 60, 'Result_RES', 'MTFValuesH2' }; ...
{ 0, 61, 'Result_RES', 'MTFValuesV3' }; ...
{ 0, 62, 'Result_RES', 'MTFValuesH3' }; ...
{ 0, 63, 'Result_RES', 'V1_GrayDist_Mean' }; ...
{ 0, 64, 'Result_RES', 'V1_GrayDist_STD' }; ...
{ 0, 65, 'Result_RES', 'V1_PeakDist_Mean' }; ...
{ 0, 66, 'Result_RES', 'V1_PeakDist_STD' }; ...
{ 0, 67, 'Result_RES', 'H1_GrayDist_Mean' }; ...
{ 0, 68, 'Result_RES', 'H1_GrayDist_STD' }; ...
{ 0, 69, 'Result_RES', 'H1_PeakDist_Mean' }; ...
{ 0, 70, 'Result_RES', 'H1_PeakDist_STD' }; ...
{ 0, 71, 'Result_RES', 'V2_GrayDist_Mean' }; ...
{ 0, 72, 'Result_RES', 'V2_GrayDist_STD' }; ...
{ 0, 73, 'Result_RES', 'V2_PeakDist_Mean' }; ...
{ 0, 74, 'Result_RES', 'V2_PeakDist_STD' }; ...
{ 0, 75, 'Result_RES', 'H2_GrayDist_Mean' }; ...
{ 0, 76, 'Result_RES', 'H2_GrayDist_STD' }; ...
{ 0, 77, 'Result_RES', 'H2_PeakDist_Mean' }; ...
{ 0, 78, 'Result_RES', 'H2_PeakDist_STD' }; ...
{ 0, 79, 'Result_RES', 'V3_GrayDist_Mean' }; ...
{ 0, 80, 'Result_RES', 'V3_GrayDist_STD' }; ...
{ 0, 81, 'Result_RES', 'V3_PeakDist_Mean' }; ...
{ 0, 82, 'Result_RES', 'V3_PeakDist_STD' }; ...
{ 0, 83, 'Result_RES', 'H3_GrayDist_Mean' }; ...
{ 0, 84, 'Result_RES', 'H3_GrayDist_STD' }; ...
{ 0, 85, 'Result_RES', 'H3_PeakDist_Mean' }; ...
{ 0, 86, 'Result_RES', 'H3_PeakDist_STD' }; ...
{ 1, 87, 'Result_RES', 'MinResolveableDetailSizeH' }; ...
{ 0, 88, 'Result_RES', 'FitResultH' }; ...
{ 0, 89, 'Result_RES', 'FitGoFH' }; ...
{ 1, 90, 'Result_RES', 'MinResolveableDetailSizeV' }; ...
{ 0, 91, 'Result_RES', 'FitResultV' }; ...
{ 0, 92, 'Result_RES', 'FitGoFV' }; ...
{ 0, 93, 'Result_RES', 'CenterX' }; ...
{ 0, 94, 'Result_RES', 'CenterY' }; ...
{ 0, 95, 'Result_RES', 'Radius' }; ...
{ 0, 96, 'Result_RES', 'AMean' }; ...
{ 0, 97, 'Result_RES', 'AoffMean' }; ...
{ 0, 98, 'Result_RES', 'SigmaMean' }; ...
{ 0, 99, 'Result_RES', 'GammaMean' }; ...
{ 0, 100, 'Result_RES', 'ASTD' }; ...
{ 0, 101, 'Result_RES', 'AoffSTD' }; ...
{ 0, 102, 'Result_RES', 'SigmaSTD' }; ...
{ 0, 103, 'Result_RES', 'GammaSTD' }; ...
{ 0, 104, 'Result_RES', 'ARobMean' }; ...
{ 0, 105, 'Result_RES', 'ARobSTD' }; ...
{ 0, 106, 'Result_RES', 'AoffRobMean' }; ...
{ 0, 107, 'Result_RES', 'AoffRobSTD' }; ...
{ 0, 108, 'Result_RES', 'SigmaRobMean' }; ...
{ 0, 109, 'Result_RES', 'SigmaRobSTD' }; ...
{ 0, 110, 'Result_RES', 'GammaRobMean' }; ...
{ 0, 111, 'Result_RES', 'GammaRobSTD' }; ...
{ 0, 112, 'Result_SL', 'CenterX' }; ...
{ 0, 113, 'Result_SL', 'CenterY' }; ...
{ 0, 114, 'Result_SL', 'Radius' }; ...
{ 0, 115, 'Result_SL', 'GridCenterX' }; ...
{ 0, 116, 'Result_SL', 'GridCenterY' }; ...
{ 0, 117, 'Result_SL', 'GridSpace' }; ...
{ 0, 118, 'Result_SL', 'GridSlope' }; ...
{ 1, 119, 'Result_SL', 'MaxError' }; ...
{ 0, 120, 'Result_SL', 'MinError' }; ...
{ 1, 121, 'Result_SL', 'MeanError' }; ...
{ 1, 122, 'Result_SL', 'STDError' }; ...
{ 0, 123, 'Result_CS', 'PixelChemicalShiftX' }; ...
{ 0, 124, 'Result_CS', 'PixelChemicalShiftY' }; ...
{ 0, 125, 'Result_CS', 'PixelChemicalShiftFull' }; ...
{ 1, 126, 'Result_CS', 'MillimeterChemicalShiftX' }; ...
{ 1, 127, 'Result_CS', 'MillimeterChemicalShiftY' }; ...
{ 0, 128, 'Result_CS', 'MillimeterChemicalShiftFull' }; ...
{ 0, 129, 'Result_CS', 'Bandwidth' }; ...
{ 0, 130, 'Result_CS', 'RelBandwidth' }; ...
{ 0, 131, 'Parameter', 'GEN' }; ...
{ 0, 132, 'Parameter', 'SNR' }; ...
{ 0, 133, 'Parameter', 'IU' }; ...
{ 0, 134, 'Parameter', 'SL' }; ...
{ 0, 135, 'Parameter', 'RES' }; ...
{ 0, 136, 'Dataset', 'Image' }; ...
{ 0, 137, 'Dataset', 'Info' }; ...
{ 0, 138, 'Dataset', 'Path' }; ...
{ 0, 139, 'Dataset', 'Index_LOC' }; ...
{ 0, 140, 'Dataset', 'Index_RES' }; ...
{ 0, 141, 'Dataset', 'Index_SL' }; ...
{ 0, 142, 'Dataset', 'Index_IU' }; ...
{ 0, 143, 'Dataset', 'Index_SNR' }; ...
{ 0, 144, 'Dataset', 'Index_CON1' }; ...
{ 0, 145, 'Dataset', 'Index_CON2' }; ...
{ 0, 146, 'Dataset', 'Index_CON3' }; ...
{ 0, 147, 'Dataset', 'Site' }; ...
{ 0, 148, 'Dataset', 'SiteCode' }; ...
{ 0, 149, 'Dataset', 'Institution' }; ...
{ 0, 150, 'Dataset', 'Manufacturer' }; ...
{ 0, 151, 'Dataset', 'Acquisition' }; ...
{ 0, 152, 'Dataset', 'Type' }; ...
{ 0, 153, 'Dataset', 'Session' }; ...
{ 0, 154, 'Dataset', 'Width' }; ...
{ 0, 155, 'Dataset', 'Height' }; ...
{ 0, 156, 'Dataset', 'BitDepth' }; ...
{ 0, 157, 'Dataset', 'Artifact' } };

AllIU       = 1;
AllSNR      = 1;
AllSL       = 1;
AllRES      = 1;
AllCS       = 1;
ONLYINDEX   = nan; %12 failed @ RES: 30, 35

%====================================

ItemBool  = cellfun(@(Line) max([   ~isempty(strfind(Line{3},'IU')) * AllIU ,...
                                    ~isempty(strfind(Line{3},'SNR')) * AllSNR ,...
                                    ~isempty(strfind(Line{3},'SL')) * AllSL ,...
                                    ~isempty(strfind(Line{3},'RES')) * AllRES ,...
                                    ~isempty(strfind(Line{3},'CS')) * AllCS ]), PlotList) .* cellfun(@(x) x{1}, PlotList);

if ~isnan(ONLYINDEX)
   ItemBool(:) = 0;
   ItemBool(ONLYINDEX) = 1;
end


ResultFolders       = dir('Phantom Results/');
ResultFolders(1:2)  = [];

if ~exist('ResultCell','var')
    
    ResultCell          = {};

    %First of all read all Result-Structs
    for ResultIndex = 1 : numel(ResultFolders)
        if ResultFolders(ResultIndex).isdir == 1
            Files       = dir(['Phantom Results/',ResultFolders(ResultIndex).name]);
            Files(1:2)  = [];
            FileNames   = {Files(:).name};
            cellfun(@(x) strcmpi('.mat',x(end - 3 : end)), FileNames(:), 'UniformOutput',0);
            MATIndex    = find(cell2mat(cellfun(@(x) strcmpi('.mat',x(end - 3 : end)), FileNames(:), 'UniformOutput',0)));
            if numel(MATIndex) ~= 1 
                MATIndex = nan;
                Error(['WARNING: Multiple .mats in ',ResultFolders(ResultIndex).name])
            else
                Result = load(['Phantom Results/',ResultFolders(ResultIndex).name,'/',FileNames{MATIndex}]);
                Result = Result.Result;
                if (strcmpi(Result.Dataset.Manufacturer,ManuLimit) || strcmpi('',ManuLimit)) ...
                 && strcmpi(Result.Dataset.Site,SiteLimit) || strcmpi('',SiteLimit)
                    ResultCell = [ResultCell; {Result}];
                    disp(['Added: ',FileNames{MATIndex}])
                end
            end
        end
    end

end

%Now plot all results
NumOfPoints   = numel(ResultCell);
FigureCounter = 1;
for ItemIndex = 1 : numel(ItemBool)
   if ItemBool(ItemIndex) == 1 
       
       
        MeanCell = {    'MANNHEIM',    [] };
       
       %Set correct items to be plottet
       ValueName    = {PlotList{ItemIndex}{3}, PlotList{ItemIndex}{4}};
       switch ItemIndex
           %case 13
           %    STDName = {PlotList{ItemIndex}{3}, 'V1_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 14
           %    STDName = {PlotList{ItemIndex}{3}, 'V1_PeakDist_STD'};
           %case 15
           %    STDName = {PlotList{ItemIndex}{3}, 'H1_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 16
           %    STDName = {PlotList{ItemIndex}{3}, 'H1_PeakDist_STD'};
           %case 17
           %    STDName = {PlotList{ItemIndex}{3}, 'V2_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 18
           %    STDName = {PlotList{ItemIndex}{3}, 'V2_PeakDist_STD'};
           %case 19
           %    STDName = {PlotList{ItemIndex}{3}, 'H2_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 20
           %    STDName = {PlotList{ItemIndex}{3}, 'H2_PeakDist_STD'};
           %case 21
           %    STDName = {PlotList{ItemIndex}{3}, 'V3_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 22
           %    STDName = {PlotList{ItemIndex}{3}, 'V3_PeakDist_STD'};
           %case 23
           %    STDName = {PlotList{ItemIndex}{3}, 'H3_GrayDist_STD'};
           %    GlobalThreshold = ResolutionThreshold;
           %case 24
           %    STDName = {PlotList{ItemIndex}{3}, 'H3_PeakDist_STD'};
           %case 95
           %    STDName = {PlotList{ItemIndex}{3}, 'STDError'};
           otherwise
               STDName          = [];
               GlobalThreshold  = [];
       end
               
       %Open New figure
       TickNames    = {};
       
       figure(FigureCounter)
       hold on
       FigureCounter = FigureCounter + 1;

       for SiteIndex = 1 : numel(ResultCell)
           if ~isempty(ResultCell{SiteIndex}.(ValueName{1}))
               if ~isempty(STDName)
                    title([ValueName{1},' : ',ValueName{2},' ± ',STDName{2}],'Interpreter','None','Fontsize',12,'Fontweight','bold');
                    ylabel([ValueName{2},' ± ',STDName{2}],'Interpreter','None','Fontsize',12,'Fontweight','bold');
               else
                    title([ValueName{1},' : ',ValueName{2}],'Interpreter','None','Fontsize',12,'Fontweight','bold');
                    ylabel([ValueName{2}],'Linestyle',':','Interpreter','None','Fontsize',12,'Fontweight','bold')
               end

               %Plot all values
               try 
                    Value    = ResultCell{SiteIndex}.(ValueName{1}).(ValueName{2});
               catch exception
                    exception
                    Value    = nan;
               end
               if ~isempty(STDName) && PlotSTD == 1
                    STD         = ResultCell{SiteIndex}.(STDName{1}).(STDName{2});
                    PointHandle = plotSTD(SiteIndex,Value,STD,Marker,MarkerSize,Color);
               else
                    PointHandle = plot(SiteIndex,Value,Marker,'LineWidth',MarkerSize,'Color',Color);
               end
               
               %Check, if corresponding slice is set to "valid" or "invalid"
               IndexID                      = (['Index_',ValueName{1}(8:end)]);
               if strcmp(IndexID, 'Index_CS')
                   IndexID = 'Index_RES';
               end
               ValidIndices(SiteIndex)      = sign(ResultCell{SiteIndex}.Dataset.(IndexID));
               
               %Store Value for Mean-Calculation
               SiteMeanIndex                = find(strcmp(MeanCell(:,1),ResultCell{SiteIndex}.Dataset.Site));
               MeanCell{SiteMeanIndex,2}    = [MeanCell{SiteMeanIndex,2}; SiteIndex, Value ];
               
           else
               Error('WARNING: Item failed during caluclation!')
               Error(['>>> ',GetSaveFileName(ResultCell{SiteIndex}.Dataset)])
               SiteMeanIndex                = find(strcmp(MeanCell(:,1),ResultCell{SiteIndex}.Dataset.Site));
               MeanCell{SiteMeanIndex,2}    = [MeanCell{SiteMeanIndex,2}; nan, nan ];
           end
           
           Name         = GetDatasetTick(ResultCell{SiteIndex}.Dataset);
           TickNames    = [TickNames, {[Name(1:2),' ',num2str(size(MeanCell{SiteMeanIndex,2},1))]}];

       end
       
       %Plot GlobalThreshold, if set
       if ~isempty(GlobalThreshold)
          GTHandle = line([0.5, numel(TickNames) + 0.5], [GlobalThreshold, GlobalThreshold],'Linewidth',1.5,'Color','green'); 
       end

       xlim([0.5, numel(TickNames) + 0.5])
       set(gca,'Xtick',1 : numel(TickNames),'XTickLabel',TickNames)
       set(gca,'FontWeight','bold','FontSize',12.0)
       
       %Adjust Ticks
       xticks = get(gca,'XTick'); %# x tick positions
       xlabels = cellstr(get(gca,'XTickLabel')); %# get the x tick labels as cell array of strings
       set(gca,'XTickLabel',[]) %# remove the labels from axes
       n = numel(xlabels);
       yl = ylim;
       Valids       = find(ValidIndices > 0); %# 1st set of ticks
       Invalids     = find(ValidIndices <= 0);
       t1 = text(xticks(Valids) - 0.3,repmat(yl(1),numel(Valids),1) - (max(get(gca,'Ylim')) - min(get(gca,'Ylim'))) / 16.6, xlabels(Valids), ...
           'HorizontalAlignment','center','VerticalAlignment','top');
       set(t1,'FontSize',12,'Rotation',90,'FontWeight','bold')
       t2 = text(xticks(Invalids) - 0.3,repmat(yl(1),numel(Invalids),1) - (max(get(gca,'Ylim')) - min(get(gca,'Ylim'))) / 16.6, xlabels(Invalids), ...
           'HorizontalAlignment','center','VerticalAlignment','top');
       set(t2,'FontSize',12,'Rotation',90,'FontWeight','bold','Color','red') %# make the 2nd set bold
       set(gca,'Fontweight','bold');
       
       %Set sizes
       set(gcf,'Position',      [608         246        1044         585]   )
       set(gcf,'OuterPosition', [600         238        1060         677]  )
       set(gca,'Position',      [0.0565    0.1008    0.9301    0.8513])
       set(gca,'OuterPosition', [-0.0995   -0.0141    1.2001    1.0445])
       
       box on
       grid on
       
       
       if PlotMeanLines == 1
           [NumOfSites, ~] = size(MeanCell);
           for Index = 1 : NumOfSites
               A             = MeanCell{Index,2};
               ValidIndicesA = find(~isnan(A(:,2)));
               Mean          = mean(A(ValidIndicesA,2));
               LineHandle    = line([min(A(:,1)) - 0.5, max(A(:,1)) + 0.5], [Mean, Mean],'Linewidth',1.5);
           end
           legend([PointHandle(end) LineHandle],'Single Value per Dataset','Mean Value per Site')
       else
           legend(PointHandle(end),'Single Value per Dataset')
       end
       
       %save plot
       if SavePlot == 1
           saveas(FigureCounter - 1,['ResultPlots\',[(ValueName{1}),'.',(ValueName{2})],'.png'], 'png')
       end
       
   end
   
end


